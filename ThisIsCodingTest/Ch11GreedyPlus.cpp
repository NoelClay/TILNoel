/*현재 상황에서 가장 좋아보이는 것만 택하는 그리디 알고리즘

정확한 최적해 공식을 짜는게 중요한 문제이다. 그럴 싸한 답을 도출해내기 만만하지만, 창의적인 다양한
방법을 요구하기에 난이도를 다양하게 내는게 가능한 문제이다.

항상 정당성을 따져가며 최적화를 하는 방식으로 문제를 해결한다.

*/

/* Q1 모험가 길드
한 마을에 모험가각 N명 있다. 모험가 길드에서는 N명의 모험가를 대상으로 '공포드'를 측정했다.
'공포도'가 높은 모험가는 쉽게 공포를 느껴 위험 상황에서 제대로 대처할 능력이 떨어진다.
모험가 길드장인 동빈이는 모험가 그룹을 안전하게 구성하고자 공포도가 X인 모험가는 반드시
X명 이상으로 구성한 모험가 그룹에 참여해야 여행을 떠날 수 있도록 규정했습니다. 동빈이는 리더이다.
최대 몇개의 모험가 그룹을 만들 수 있는지 구하는 문제
N명의 모험가에 대한 정보가 주어졌을 때, 여행을 떠날 수 있는 그룹 수의 최댓갑을 구하는 프로그램

예를 들어  2 3 1 2 2 라는 공포도 정보가 있다면
3은 3명 이상인 그룹을 구성해야만 구성원으로 들어갈 수 있기에
1 혼자
3 2 2 세명
2 마을 
이런식으로 구성하여 2팀이 나가는 경우도 가능하고
1 혼자
2 2 두명
2 3 마을 이런식으로 두팀도 가능하고 상당히 많은 방법이 있겠지만 결국 두 팀이 최대 가능 팀이므로
2가 출력되어야 한다.

N은 10만이하 자연수들은 둘째 줄 부터 공백으로 구분하여 입력됨.

입력 예시			출력예시	2
5					
2 3 1 2 2

<접근방법>
내가 생각하기에 최소의 인원으로 구성된 팀이 많아질 수록 팀의 숫자가 가장 많을거 같다.
따라서 정렬을 한 번한 뒤에 최소공포도로 구성 가능한 애들끼리 구성을 하고 공포도가
큰 녀석들은 마을에 재껴 두는게 가장 효과적이지 않나? 결국 이 공식은 평균 공포값은 의미 없이
공포도가 큰 녀석이 끼는 순간 그만큼 숫자를 구성해야되는 문제이기 때문에
2 2 2 2 2 2 3 이라면 그냥 2끼리 2명 고용하는게 베스트이다. 평균값을 위해 여러 조합을 고려할 필요가 없다.
최대값의 영향력이 지대적이기 때문이다.
*/
#if 1
#include<iostream>
#include<algorithm>
using namespace std;

int main()
{
	int N;
	cout << "모험가는 총 몇명인가? : ";
	cout << "각 모험가의"
}

#endif // 1
