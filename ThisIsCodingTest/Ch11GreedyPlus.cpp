/*현재 상황에서 가장 좋아보이는 것만 택하는 그리디 알고리즘

정확한 최적해 공식을 짜는게 중요한 문제이다. 그럴 싸한 답을 도출해내기 만만하지만, 창의적인 다양한
방법을 요구하기에 난이도를 다양하게 내는게 가능한 문제이다.

항상 정당성을 따져가며 최적화를 하는 방식으로 문제를 해결한다.

*/

/* Q1 모험가 길드
한 마을에 모험가각 N명 있다. 모험가 길드에서는 N명의 모험가를 대상으로 '공포드'를 측정했다.
'공포도'가 높은 모험가는 쉽게 공포를 느껴 위험 상황에서 제대로 대처할 능력이 떨어진다.
모험가 길드장인 동빈이는 모험가 그룹을 안전하게 구성하고자 공포도가 X인 모험가는 반드시
X명 이상으로 구성한 모험가 그룹에 참여해야 여행을 떠날 수 있도록 규정했습니다. 동빈이는 리더이다.
최대 몇개의 모험가 그룹을 만들 수 있는지 구하는 문제
N명의 모험가에 대한 정보가 주어졌을 때, 여행을 떠날 수 있는 그룹 수의 최댓갑을 구하는 프로그램

예를 들어  2 3 1 2 2 라는 공포도 정보가 있다면
3은 3명 이상인 그룹을 구성해야만 구성원으로 들어갈 수 있기에
1 혼자
3 2 2 세명
2 마을 
이런식으로 구성하여 2팀이 나가는 경우도 가능하고
1 혼자
2 2 두명
2 3 마을 이런식으로 두팀도 가능하고 상당히 많은 방법이 있겠지만 결국 두 팀이 최대 가능 팀이므로
2가 출력되어야 한다.

N은 10만이하 자연수들은 둘째 줄 부터 공백으로 구분하여 입력됨.

입력 예시			출력예시	2
5					
2 3 1 2 2

<접근방법>
내가 생각하기에 최소의 인원으로 구성된 팀이 많아질 수록 팀의 숫자가 가장 많을거 같다.
따라서 정렬을 한 번한 뒤에 최소공포도로 구성 가능한 애들끼리 구성을 하고 공포도가
큰 녀석들은 마을에 재껴 두는게 가장 효과적이지 않나? 결국 이 공식은 평균 공포값은 의미 없이
공포도가 큰 녀석이 끼는 순간 그만큼 숫자를 구성해야되는 문제이기 때문에
2 2 2 2 2 2 3 이라면 그냥 2끼리 2명 고용하는게 베스트이다. 평균값을 위해 여러 조합을 고려할 필요가 없다.
최대값의 영향력이 지대적이기 때문이다.
*/
#if 0
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

int main()
{
	int N, answer=0;
	cout << "모험가는 총 몇명인가? : ";
	cin >> N;
	cout << "각 모험가의 공포도를 띄어쓰기로 전부 적어라." << endl;
	vector<int> feers(N);
	vector<int> checkstack;
	for (auto& n : feers) cin >> n;

	//1.먼저 정렬을하자.
	sort(feers.begin(), feers.end());
	//2. 탐색을 하면서 최대 인원수가 조정된다. 1일땐 추가 없이 끝 2일땐 하나 더 추가하고 다시 탐색할때
	//2라서 종료조건을 만족하면 끝
	for (int i = 0; i < feers.size(); i++) {
		int now = feers[i];
		checkstack.push_back(now);
		if (checkstack.size() == now) {
			answer++; checkstack.clear();
		}
	}
	
	cout << endl << answer;
}

#endif // 1
/*Q.02. 곱하기 혹은 더하기
각 자리가 숫자로만 이루어진 문자열 S가 주어졌을때 왼쪽부터 오른쪽으로 하나씩 모든
숫자를 확인하며 숫자 사이에 'X'혹은 '+' 연산을 넣어 결과적으로 가장 큰 수를 구하는
프로그램을 작성하라. 단, +보다 X를 먼저 계산하는 일반적인 사칙연산과 달리 순서대로
이루어진다. 예를들어 02984가 주어지면 0+2x9x8x4 로 576이고 567이면 5x6x7 로 210

<접근방법>
곱하기가 더하기보다 무조건 크다. 1과 0사이만 아니라면 어떤 숫자를 상대로도 마찬가지
두개의 문자열을 꺼내서 0 혹은 1이 있는지 확인하고 케이스 2가지 중에 하나를 선택함
그 다음부터는 하나씩 꺼내면서 계속 반복*/
#if 0
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

int main() {
	cout << "숫자로만 이루어진 문자열을 입력하세요." << endl;
	string numbers;
	cin >> numbers;
	vector<int>temp;
	int answer = 0, tempi;
	
	if (numbers.size() <= 1) {
		cout << "문자열의 길이는 1입니다. 따라서" << endl;
		cout << numbers[0];
		return -1;
	}
	else {
		temp.push_back(numbers[0] - '0');
		temp.push_back(numbers[1] - '0');
		if (temp[0] <= 1 || temp[1] <= 1) { //둘 중에 하나라도 0이나 1이면 더하기
			answer = temp[0] + temp[1];
		}
		else	answer = temp[0] * temp[1];
		for (int i = 2; i < numbers.size(); i++) {//만약에 넘버의 사이즈가 2이하라면 실행도 안되겠지.
			tempi = numbers[i] - '0';
			if (answer <= 1 || tempi <= 1) {
				answer += tempi;
			}
			else	answer *= tempi;
		}
		cout << endl << answer;
	}
}


#endif
/*Q03 문자열 뒤집기
다솜이는 0과 1로만 이루어진 문자열 S를 가지고 있다. 다솜이는 문자열 S에 있는 모든 숫자를 전부 같게 만드려고한다.
다솜이가 할 수 있는 행동은 S에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것.
뒤집는 것은 1을 0으로 0을 1로 바꾸는 것을 의미한다. 예를들어 00011000 일때
전체를 뒤집는 거 1번 11100111
중간에 0 뒤집으면 111111로 조건을 만족하여 2번이다
하지만 처음부터 마지막까지 뒤집고 중간부터 중간까지 뒤집을 필요 없이 처음부터 중간에 11을 뒤집으면 00이되어
00000000이 되어버린다.그러면 최소 횟수 1만으로 만족하는 것이다.
어디서부터 뒤집을지는 자유다 단 한번 뒤집기 시작하면 끊었다가 다시 어디부터 뒤집는건 안된다. 연속적으로 뒤집어야함.
그걸 1회로 친다.

<접근방법>
애초에 다 뒤집을 이유가 있나? 이 문제는 결국 연속되어있는 애들을 뒤집어야 되는 문제이다. 그런데 정답은 
꼭 1어야 하는것도 꼭 0이어야 하는 것도 아니다. 0으로 만드는게 유리한지 1로 만드는게 유리한지를 체크한다음에
그냥 연속적인 애들의 구간 만큼이 최소 반복횟수 아닐까? 0이 더 많은지 1이 더 많은지가 아니라 
연속된 구간의 개수가 중요하다. 어차피 연속된 구간은 인덱스로 접근할 것이다. 나는 pair배열로 인덱스 구간을 집계하여
저장하는 방식이 적절할거라고 본다. 그리고 배열의 길이를 비교하면 그게 바로 연속된 구간의 개수가 된다.
<스택>
연속된 녀석들을 비교할때 가장 유용한건 아마 스택 자료형이 아닐까 한다.
*/
#if 0
#include <iostream>
#include<string>
#include<vector>
#include<stack>
using namespace std;

int main() {
	string s;
	cout << "0과 1로만 이루어진 문자열 입력하시오" << endl;
	cin >> s;
	int answer = 0, startidx = 0;
	vector<pair<int, int>> oneIdxs;
	vector<pair<int, int>> zeroIdxs;
	stack<int>check;
	int i = 0;
	/*연속된 숫자를 체크하는건 결국 이전 인덱스와 지금인덱스 혹은 지금인덱스와
	이후 인덱스가 같은 요소를 저장하고 있는지만 체크하면 된다. 그 변곡점을
	저장하면 구간을 저장하는 것이 될터이고 그 구간의 개수가 더 적은쪽이 답이다.*/
	for (int i = 1; i < s.size(); i++) {
		int j = i - 1; //항상 이전 인덱스를 가르킬 것이다.
		if (s[j] == s[i]) {
			continue;
		}
		else if (s[j] == '0') { //원래 0이 연속적이었는데 지금 1을 발견한거니까.
			zeroIdxs.push_back({ startidx, j });
			startidx = i;
		}
		else if (s[j] == '1') {
			oneIdxs.push_back({ startidx, j });
			startidx = i;
		}
	}
	//다 돌았으면 한번 체크를 해줘야된다. 변곡점이 마지막에 있었는지 없었는지에
	//따라 달라진다. 만약 변곡점이 없었다면 하나 추가하면되고, 변곡점이 있었다면
	//마지막 변곡점에 해당하는 요소를 추가한다.
	if (s[s.size() - 2] == s[s.size() - 1]) { //같다면
		if (s[s.size() - 1] == '0') {
			zeroIdxs.push_back({ startidx, s.size()-1 });
		}
		else{
			oneIdxs.push_back({ startidx, s.size() - 1 });
		}
	}
	else//같지 않다면 이미 변곡점이 하나 생성되어 추가되어 있고 마지막인덱스에
	{//대한 요소값만 추가해주면 끝
		if (s[s.size() - 1] == '0') {
			zeroIdxs.push_back({ s.size() - 1, s.size() - 1 });
		}
		else {
			oneIdxs.push_back({ s.size() - 1, s.size() - 1 });
		}
	}
	int zerogroupcnt = zeroIdxs.size();
	int onegroupcnt = oneIdxs.size();
	if (zerogroupcnt > onegroupcnt) cout << onegroupcnt;
	else cout << zerogroupcnt;

}
#endif // 1

/* 04 만들 수 없는 금액
동네 편의점의 주인인 동빈이는 N개의 동전을 가지고 있다. 이때 N개의 동전을 이용하여
만들 수 없는 양의 정수 금액 중 최솟값을 구하는 프로그램을 작성하세요.
예를 들어, N=5이고, 각 동전이 각각 3원, 2원, 1원, 1원, 9원짜리 동전이라고 가정하자.
이때 동빈이가 만들 수 없는 양의 정수 금액 중 최솟값을 8원이다.

입력조건 : 양의 정수 N 1000이하
N개의 자연수가 주어지며, 각 자연수는 공백으로 구분된다. 이때 각 화폐는 백만이하
출력조건 : 첫째 줄에 주어진 동전들로 만들 수 없는 양의 정수 금액 중 최솟값을 출력한다.

입력 예시				출력 예시
5						8
3 2 1 1 9

<접근방법>
도저히 모르겠어서 책을 읽고 알아낸 내용을 다시 복기해서 써본다.
대표적인 그리디스러운 문제라고 한다. 

어떠한 타겟금액을 만들기 위해 필요한 최소화폐값을 만족하는지를 확인하며 최솟값을 찾아나가는게
핵심이다. 처음에는 target이 당연히 1이며 이를 충족하기 위해선 target보다 작거나 같은 금액이어야 하는데
최소값은 1이어야하니까 1이 있어야만 한다.
그래 1이 있다면 그 다음에 찾아야되는 타겟값은 2이다. 2를 만들기 위해선 어떤 화폐가 필요할까? 2가 있거나
2보다 작은 1이 있어야 한다. 이것 또한 타겟보다 작거나 같은 값이다. 2가 있다고 치자. 그럼 어디까지 만들수 있어?
2+1은 3까지 만들 수 있다.  그렇기에 다음 타겟값은 4가 된다. 4보다 작거나 같은 값인 1 2 3 4 중에 하나라도 있다면
4를 만들 수 있다.
2가 있다고 치자 2+2는 4니까 4를 만들 수 있고 2+2+1은 5니까 5도 만들 수 있다. 그다음 타겟값은 기존 타겟값
4+2인 6이 타겟값이 된다.
만약 3이 있다고 치자 1+3=4니까 4를 만들 수 있고 2+3=5 1+2+3=6 까지 만들 수 있으니까 다음은 7이다.
그 7은 어떻게 나오는거야? 기존 타겟 + 3인 4+3=7 이다.
만약 4가 있다고 치자. 요소값 그자체가 4를 만들고 4+1 4+2 4+1+2 인 7까지 만들 수 있으니까 다음 타겟은 4+4인 8이다.

즉 이 타겟값의 의미는 만들 수 있는 모든 조합 다음의 최소값이 바로 타겟값이다. 그 타겟값을 만들기 위해선 타겟값보다
작거나 같은 수가 있어야. 타겟을 만족하게 되는 것이다. 수학적인 공식으로는 설명하기 힘들지만 그냥 이렇다고 이해하는게
제일 나을 것 같다.
*/
#if 0
#include<vector>
#include<iostream>
#include<algorithm>
using namespace std;

int solution(vector<int> arr) {
	//1. 오름차순 정렬을 한 뒤에
	sort(arr.begin(), arr.end());
	//처음 타겟은 1이다. 1을 만족시킬 만한 1보다 작거나 같은 자연수인 1이 있는지 확인
	int target = 1, answer = target;
	for (auto n : arr) {
		//만약 타겟보다 작거나 같아서 만족 시킨다면 다음 타겟은 이 조합으로 만들 수 있는 조합중 
		// 다음 값이 최소값이 될 것이고 그 최소값보다 작거나 같은 요소가 있어서 그 최소값을 만들
		//수 있는지를 조회한다. 만약 조회했을때 그 최소값을 만족할 수 있다면 다음 가능한 조합보다 1큰수인
		//타겟을 갱신한다.
		if (n <= target) {
			//arr의 요소가 target보다 작거나 같으면 타겟을 만들 수 있다는 반증 
			//다음 타겟값을 갱신한다. 어떻게 target + n으로 왜냐하면 target은 이미 오름차순으로 정렬된
			//요소값들을 하나씩 조회할때마다 만들 수 있는 조합들에서 1큰 수 이기때문이다. 
			//다음 요소값인 n이 타겟을 만드는데 기여할 수 있다는 것을 발견했으니 기존에 target에 n을 더하면
			//다음 타겟이 되는 것은 당연한 진리?
			target += n;
		}
		else
		{
			return target;
		}
	}
	return target;
}

int main() {
	cout << "첫째줄에는 총 요소의 개수 N이 주어진다." << endl;
	int N;
	cin >> N;
	cout << "그 다음 줄에는 각 요소의 값이 공백을 기준으로 주어진다." << endl;
	vector<int> arr(N);
	for (auto& n : arr) {
		cin >> n;
	}
	cout << "결과는 : " << solution(arr);
}

#endif // 1

/*Q 05 볼링공 고르기
A,B 두 사람이 볼링을 치고 있다. 두 사람은 서로 무게가 다른 볼링공을 고르려고 한다.
볼링공은 총 N개가 있으며 각 볼링공마다 무게가 적혀있고, 공의 번호는 1번부터 순서대로
부여된다. 또한 같은 무게의 공이 여러 개 있을 수 있지만, 서로 다른 공으로 간주한다. 볼링공의
무게는 1부터 M까지의 자연수 형태로 존재한다.

예를들어 N이 5이고, M이 3이고, 1 3 2 3 2가 차례로 주어지면 1번부터 5번까지 볼링공의 무게가
정해진게 된다. 두 사람은 동시에 다른 공이면서 다른 무게를 들어야만한다. 그 경우의 수는 다음과 같다.
(1, 2)(1, 3)(1, 4)(1, 5)(2, 3)(2, 5)(3, 4)(4, 5)
총 8개의 조합이 나온다.

입력 조건
첫째 줄에 볼링공의 개수 N, 공의 최대 무게 M이 공백으로 구분되어 자연수로 주어진다. N은 천이하 M은 10이하
둘째 줄에 각 볼링공의 무게가 공백으로 구분되어 선수대로 자연수로 주어짐 최대값 M보다 작은 자연수들이 주어짐
출력조건
첫째 줄에 두사람이 볼링공을 고르는 경우의 수를 출력한다.

<접근방법>
어떤 사람이 어떤 공을 들어야되는지에 대한 조건은 중요하지 않다. 이는 a, b 순서는 중요하지 않다는 뜻
고려해야될 조건은 서로 다른 공이면서 다른 무게를 들어야 된다는 점이다. 이는 간단한 식을 세울 수 있다.
한번 조회한 공은 다시 조회할 필요가 없다. 경우의 수에서 빠져야되니까. 즉 이말은 다음과 같다.
1번 공과의 조화를 한번 살펴본다. 그렇게 조화를 카운팅 했으면 다음번에는 1번공과의 조화는 따질 필요가 
없다는 뜻이다. 개념적으로 이 모든것을 다 따져야되는 경우가 필요할 수 도 있지만, 이 문제는 생각보다 간단하다.
계수정렬의 아이디어가 있다. 범위가 작은 값을 정렬할때 각 수들을 인덱스로 가지는 범위를 저장하는 크기의 계수배열을
하나 만든다. 그 다음에 각 인덱스마다 그 인덱스에 해당하는 수를 발견할때마다 카운트를 증가시켜 저장한다.
그 다음에 계수 배열을 조회하며 카운트 수만큼 인덱스를 출력하면 오름차순 출력이 완성된다.
이러한 아이디어를 활용하여 각 무게별로 계수배열을 만든다. 그 다음에 순서대로 조회한다. 어떤 무게 x를 가지는 공이
순서에 오면 그 X를 제외한 나머지 계수들만큼 조합이 가능하고 해당 X에 해당하는 계수는 -1해주면 다음번에 그 X무게를 가지는
공 하나를 조회하지 않는다는 의미가 된다.

*/
#if 0
#include<iostream>
#include<vector>
using namespace std;

int solution(vector<int>(&cntarr), vector<int> arr) {
	//main()에서 판을 다 깔아놓았기에 그냥 바로 본론으로 적용한다.
	int answer = 0;
	for (auto n : arr) { //데이터 배열에서 하나를 뽑아 조회한다.
		//이 데이터와 다른 무게값을 가지는 카운트들을 더한다.
		for (int i = 1; i < cntarr.size(); i++) {
			if (n != i && cntarr[i] >= 0) {
				answer += cntarr[i];
			}
			else {
				cntarr[i]--;
			}
		}
	}
	return answer;
}

int main()
{
	cout << "첫째 줄에 요소 개수N과 최대값M을 공백으로 구분하여 입력하세요" << endl;
	cout << "N은 1000이하 M은 10이하 입니다." << endl;
	int N, M;
	cin >> N >> M;
	cout << "각 공의 무게를 순서대로 입력하세요. 총 N개를 입력하고 무게는 M이하여야 합니다." << endl;
	vector<int> countarr(M+1);
	vector<int> dp(N);
	for (int i = 0; i < N; i++) {
		int temp;
		cin >> temp;
		countarr[temp]++; //계수배열처럼 그 인덱스에 해당하는 값을 하나 증가한다.
		dp[i] = temp; //실제 주어지는 순서대로 무게를 저장하는 배열
	}
	cout << "모든 경우의 수는 " << solution(countarr, dp);
}

#endif // 1
/*Q 06 무지의 먹방 라이브
평소 식욕이 왕성한 무지는 자신의 재능을 뽐내고 싶어졌고 고민 끝에 카카오tv 라이브 방송을
하기로 마음 먹었습니다. 그냥 먹방을 하면 다른 방송과 차별성이 없기 때문에 무지는 다음과 같이
독특한 방식을 생각해냈습니다.
회전판에 먹어야할 N개의 음식이 있다. 각 음식에는 1부터 N까지의 번호가 붙어있으며, 각 음식을
섭취하는데 일정 시간이 소요됩니다. 무지는 다음과 같은 방법으로 음식을 섭취합니다.

1. 무지는 1번 음식부터 먹기 시작하며, 회전판은 번호가 증가하는 순서대로 음식을 무지 앞으로
가져다 놓습니다.
2. 마지막 번호의 음식을 섭취한 후에는 회전판에 의해 다시 1번 음식이 무지 앞으로 옵니다.
3. 무지는 음식 하나를 1초 동안 섭취한 후 남은 음식은 그대로 두고, 다음 음식을 섭취합니다.
다음 음식이란, 아직 남은 음식 중 다음으로 섭취해야 할 가장 가까운 번호의 음식을 말한다.
4. 회전판이 다음 음식을 무지 앞으로 가져오는데 걸리는 시간은 없다고 가정한다.

무지가 먹방을 시작한 지 k초 후에 네트워크 장애로 인해 방송이 잠시 중단되었다. 무지는 네트워크
정상화 후 다시 방송을 이어갈 때, 몇 번 음식부터 섭취해야 하는지를 알고자 합니다.
각 음식을 모두 먹는 데 필요한 시간이 담겨 있는 배열 food_times, 네트워크 장애가 발생한 시간 k초가
매개변수로 주어질 때 몇 번 음식부터 다시 섭취하면 되는지 return

제한사항
food_times는 각 음식을 모두 먹는 데 필요한 시간이 음식의 번호 순서대로 들어 있는 배열. 길이:2000이하 원소크기:1000이하
k는 방송이 중단된 시간을 나타냄 k는 2백만이하
만약 더 섭취할 음식이 없다면 -1을 반환하면 된다.

효율성 제한사항
food times의 길이는 2십만이하 각 원소의 크기는 1억이하
k는 2조 이하의 자연수

입출력 예시
food_times = {3, 1, 2}
k = 5
result = 1

입출력 예시에 대한 설명 처음엔 {3, 1, 2}
0~1초 동안에 1번 음식을 섭취한다. 남은 시간은 {2,1,2}이다.
1~2초 동안에 2번 음식을 섭취한다. 남은 시간은 {2,0,2}
2~3초 동안에 3번 음식을 섭취한다. 남은 시간은 {2,0,1}
3~4초 동안에 1번 음식을 섭취한다. 남은 시간은 {1,0,1}
4~5초 동안에 (2번 음식 없으니까) 3번 음식을 섭취. 남은시간 {1,0,0}
5초에서 네트워크 장애가 발생. 1번 음식을 섭취해야할 때 중단되었으므로,
장애 복구 후에 1번 음식부터 다시 먹기 시작하면 된다.

<접근방법>
네트워크 장애 시간이 k라면 0초에서 k초 직전까지 즉 총 k번 음식을 먹고나서
k번째에 먹어야될 음식을 반환하면 되고 그 전에 다먹으면 -1이라는 소리.
들어간 순서대로 회전하는 구현은 결국 큐를 사용해야 될것 같다. 큐에는 1번 2번 3번
과 같이 순서에 대한 정보가 큐에 들어가고 그 큐에 들어있는 정보를 읽어서 큐에 푸쉬해야될지
말아야될지를 결정하는 것은 그 순서정보를 인덱스로 하여 남아있는 음식량 정보가 들어있는 
배열일 것이다.
즉 자료를 받을때 food_times의 길이만큼이 인덱스가 되어 그 인덱스 숫자가 큐에 순서대로 들어가고
큐에서 팝할때마다 food_times의 요소값을 -1하고나서 0이 되었다면 더이상 큐에 들어가지 않아서
조회되지도 않을 것이다. 그렇게 총 k번 반복을 하고 나서 다음 순서로 pop되는 순서가 있다면 그것을 반환하고
반환할 값이 없다면 -1이다.
그런데 -1 예외를 살펴보자. 결국 무지는 쉬지 않고 먹을 것이다. 네트워크 오류가 걸리는 시간은 즉 무지가 먹는
양과 관련이 있다. 무지가 먹어야될 총 음식량이 네트워크 오류가 나는 시간보다 적다면 무조건 -1이고
아니라면 무슨 초이든 반환될 것이다.
그런데 이런 구현방식으로는 시간초과를 면치 못할 것이다... fodd_times의 값을 하나씩 줄여서 확인한다는 것인데...
수학적으로 해결하는 방법이 분명 존재하긴 할 것이다. 일다 구현도 난이도가 있기에 구현부터 해본다.
*/
#if 0 //문제에서 주어진 조건 그대로 구현한 코드
#include <string>
#include <vector>
#include <queue>
#include <iostream>

using namespace std;

int solution(vector<int> food_times, long long k) {
	int answer = 0;
	int N = food_times.size();
	queue<int> idxQ;
	for (int i = 1; i <= N; i++) idxQ.push(i);

	for (int i = 0; i < k; i++) {
		if (idxQ.empty()) return -1;
		int temp = idxQ.front();
		food_times[temp - 1]--;
		if (food_times[temp - 1] != 0) {
			idxQ.push(temp);
		}
		idxQ.pop();
	}
	if (idxQ.empty()) return -1;
	else answer = idxQ.front();

	return answer;
}
int main() {
	cout << "네트워크 오류가 날 시간 K를 입력" << endl;
	long long k;
	cin >> k;
	vector<int> food_times = { 3, 1, 2 };
	cout << "결과는 " << solution(food_times, k);
}
#endif // 1

#if 0 //효율성 테스트 통과를 위해 개선.
/*<개선 아이디어>
1. food_times의 총 시간보다 오류 시간 k가 같거나 크다면 무조건 -1이 날 것이다.
2. 결국 한바퀴 도는 동안 하나씩 초가 감소할 것이다. 한바퀴를 도는 시간은 각 바퀴마다 남아있는 음식량에따라
달라 지겠지만, 한바퀴를 돌때 소요되는 시간은 남아있는 음식의 수이다. 양은 0이상이면 카운트 될 것이다.
food_times를 하나 더 복사해서 오름차순 정렬을 하면 먼저 떨어져 나가는 음식이 맨 앞으로 올것이다. 
남아있는 k를 조회하여 어떻게 하며 될것같은데...
3. k를 fodd_times의 길이만큼 나누면 나머지는 따지지 않고 해가 나올 것이다. 총 몇바퀴를 돌아야 할지를 계산
하는 것이다. 하지만 이렇게 쉽게 돌아가지 않는다. 음식이 다 떨어지면 포함하면 안되기때문이다.
최소량의 음식이 바퀴 수에 포함되는건 음식의 량만큼이다.음식이 1이라면 1바퀴에만 포함될 것이고 3이라면 3바퀴 돌때까지
포함될 것이다. 그렇다면 일단 그 해가 최소 음식량보다 작다면 합격이다. 같다면 다음 바퀴에 포함안된 나머지를 계산해야되고
크다면 더 많이 돌아야 한다. 만약 작을 경우엔 나머지를 구했을때 그 나머지가 음식 순서 1 2 3 4 5 6 순으로 먹을 것이기때문에
나머지가 곧 음식의 순서일 것이다. 정확히는 네트워크 오류가 발생하는 순서가 될것이고 그 다음이 바ㅗ 음식을 먹는 순간이다.
*/

#include <string>
#include <vector>
#include <queue>
#include <iostream>

using namespace std;

int solution(vector<int> food_times, long long k) {
	int answer = 0;
	int N = food_times.size();
	queue<int> idxQ;
	for (int i = 1; i <= N; i++) idxQ.push(i);

	for (int i = 0; i < k; i++) {
		if (idxQ.empty()) return -1;
		int temp = idxQ.front();
		food_times[temp - 1]--;
		if (food_times[temp - 1] != 0) {
			idxQ.push(temp);
		}
		idxQ.pop();
	}
	if (idxQ.empty()) return -1;
	else answer = idxQ.front();

	return answer;
}
int main() {
	cout << "네트워크 오류가 날 시간 K를 입력" << endl;
	long long k;
	cin >> k;
	vector<int> food_times = { 3, 1, 2 };
	cout << "결과는 " << solution(food_times, k);
}
#endif