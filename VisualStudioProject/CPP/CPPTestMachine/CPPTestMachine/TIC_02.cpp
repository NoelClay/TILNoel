// 1번
// 다음 두 함수 원형에서 잘못된 점은 무엇인지 답하시오.
// int TestFunc(int nParam1 = 5, int nParam2, int nParam3 = 10)
// int TestFunc(int nParam1 = 5, int nParam2)
// 
// <2.1 디폴트 매개변수>
// 유의해야되는 점은 호출자만 보고서는 이게 디폴트 매개변수가 있는 함수인지, 매개변수가 원래 없는 함수인지 알 수가 없다.
// 디폴트 매개변수 선언의 규칙
// 1. 피호출자 함수 매개변수의 디폴트 값은 반드시 오른쪽 매개변수부터 기술해야된다.
// 왜냐하면 매개변수가 총 3개인데 호출자에선 1개만 실인수를 전달한다면 맨 왼쪽부터 매개변수에 전달하기 때문에
// 디폴트 매개변수 정의를 한다면 맨 오른쪽부터 기술해야한다.
// 2.매개변수가 여러개일때는 왼쪽이 디폴트 매개변수이고 오른쪽도 디폴트 매개변수라면 가운데도 반드시 디폴트여야함.
// 왜냐하면 그래야 실인수 전달 순서에 오류없이 규칙을 유지할수 있기 때문이다.
// 3.호출자에서 실인수를 기술한다면 피호출자의 매개변수 맨 왼쪽부터 차례대로 짝을 맞추어 적용한다.
// 
// <답>
// 첫 번째는 2번 규칙을 어겼다.
// 두 번째는 1번 규칙을 어겼다.
//
#if 0
#include<iostream>
int main()
{

}

#endif

//2번
// 다음 두 함수는 문법적으로 문제가 없다. 하지만 호출하는 코드에서는 문제가 발생할 수도 있다. 어떤 문제일까?
// 
// void TestFunc(int a)
// {
//     cout << "TestFunc(int)" << endl;
// }
// void TestFunc(int a, int b = 10)
// {
//     cout << "TestFunc(int, int)" << endl;
// }
// 
// <답>
// 호출할때 실인수 한 개를 전달할때 모호성 문제가 발생할 것이다. 둘 다 실인수 한개를 전달할때 피호출자 대상이기 때문이다.
//
#if 0
#include<iostream>
int main()
{

}

#endif

// 3번
// 함수를 다중 정의하는 것보다는 함수 템플릿이 더 좋은 코드가 될 가능성이 높다. 이유를 답하시오.
// 
// <답>
// 같은 함수의 이름을 여러개 만들어서 각기 다른 반환형식 각기 다른 매개변수 모든 경우의 수를 다 그렇게 정의하는데 
// 모호성이 발생할 확률이 높다.
// template <typename T>	라는 문장을 추가하고
// T test(T a){
//     cout << a << endl;
//     return a;
// }
// 위와 같은 형식으로 구성된 함수는 반환형식도 실인수로 통일하고 실인수의 자료형이 곧 매개변수 자료형으로 자동으로 맞춰지는
// 형태의 함수가 된다. 일단 단순하지만 모호성 문제는 상당히 해결된다. 호출할때도 단순하게 오류가 발생하지도 않는다.
//
#if 0
#include<iostream>
int main()
{

}

#endif

// 4번
// inline 함수와 매크로의 공통된 장점은 무엇인가?
// 
// <답>
// 함수라는 건 코드를 간결하게 만들어주고 기능을 외부적으로 빼줌으로써 가독성을 높여주는 역할을 하고 
// 호출자를 통해 같은 기능을 바로바로 사용할 수 있게 해준다.
// 하지만 함수 호출에 고려해야될 점은 스택공간을 상당히 많이 쓰기도 한다는 것이다. 함수를 호출할때 스택에 실인수를 복사해서 올리고
// 함수가 메모리를 많이 쓴다면 그 메모리량은 고스란히 스택을 차지한다. 이때 스택오버플로가 일어날 수도 있다. 
// 메모리 복사가 자주 일어나면서 중첩까지 된다면 스택오버플로 발생가능성은 더욱 높아진다.
// 그래서 사용하는게 매크로와 inline 함수이다.
// 
// 먼저 매크로는 함수가 아니기에 추가 호출시 메모리 복사가 일어나지 않는다. 그러면서 반복되는 코드를 외부로 빼내고 간단한 이름으로
// 자주사용하는 코드를 메모리 복사없이 사용함으로써 스택의 효율성을 높이고자 하는게 그 목적이다. 하지만 매개변수 형식의 지정이
// 불가하기때문에 논리적이지 않은 실인수가 사용될 경우 연산자 오류 등의 문제가 발생할 수 있는 모호성도 있다.
// 
// 메모리복사는 사용하지 않으면서 매크로의 모호성을 극복하고자 나온 것이 inline함수 기능이다. inline함수는 논리적 오류를 예방하기 위해
// 매개변수의 형식이 미리 지정되고, 그 형식에 맞지 않은 연산은 컴파일 에러로 방지할 수 있다.
// 
// 하지만 매크로나 inline이나 메모리복사의 문제를 해결하기 위해 나온 개념이지만 단점은 그 기능의 코드길이가 긴 것은 내부 매크로나
// 내부 inline으로 정의해 두는 것은 오히려 스택에 상주하여 스택을 괴롭힐 수도 있다고 한다.
// 
// 바람직한 코드길이에만 inline함수를 사용하는 것이 좋은데 그 것은 걱정할 것이 없는게 visual studio는 최적화 기능을 제공하여
// inline으로 적합한건 내부 inline함수로 알아서 컴파일하고, 내부 연산자가 많이 필요한건 외부 함수로 빼서 최적화 컴파일한다.
//
#if 0
#include<iostream>
int main()
{

}

#endif

// 5번
// 네임스페이스를 매번 작성하기 싫다면 미리 () 선언을 하는 것이 좋다. 괄호를 채워라
// 
// <답>
// using namespace 이름;
//
#if 0
#include<iostream>
int main()
{

}

#endif

// 6번 다음 코드의 실행 결과를 작성하세요.
// 중략...
// 
// <답>
// 100
//
#if 0
#include<iostream>
int main()
{

}

#endif

#if 0
#include<iostream>
int main()
{

}

#endif