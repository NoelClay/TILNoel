/*
<1> 아이디어를 코드로 바꾸는 구현

<피지컬로 승부하기>
코딩에서 피지컬이란 구현하기 까다로운 문제들을 짜는 능력을 의미함.
구현이 알고리즘이냐고 물어보면 알고리즘은 아니지만, 알고리즘을 코드화 하기위해서 반드시 필요한 능력이 구현이다.
취업용 코딩테스트에서는 구현문제가 자주나오기에 다룸.

완전 탐색과 시뮬레이션은 모두 구현으로 묶어서 다룸.
완전탐색: 모든 경우의 수를 주저 없이 다 계산하는 방법.
시뮬레이션: 문제에서 제시한 알고리즘을 한 단계씩 차례로 직접 수행하도록 구현하는 방식.

<구현 시 고려해야 할 메모리 제약 사항>
int 범위를 넘어가는건 long long 사용하고, long long 범위를 넘어가는 경우는 거의 없다고 봐야한다.

메모리 제약은 보통 작게는 128mb 부터 크게는 512mb 까지 메모리 사용량을 제한한다.

<채점 환경>
보통 일반적으로 시간 제한과 메모리 제한은 각각 1초 128mb를 건다.
대강 2천만번의 연산을 수행하면 1초 정도가 걸린다고 본다.
만약 N이 백만이라면 NlogN은 약 2천만번이 나온다.

문제에서 주어진 시간 제한과 데이터 용량 제한을 확인하고,
어떤 시간복잡도로 얼만큼 메모리를 차지하며 문제를 구현해야할지 고려해야한다.

*/

/* 4-1 상하좌우
여행가 A는 N x N 크기의 정사각형 공간 위에 서 있다. 이 공간은 1 x 1 크기의 정사각형으로 나누어져 있다.
가장 왼쪽 위는 (1,1) 이고 가장 오른쪽 아래는 (N,N)이다. 여행가 A는 상하좌우 방향으로 이동할 수 있으며, 시작 좌표는 항상
(1,1)이다. 우리 앞에는 여행가 a가 이동할 계획이 적힌 계획서가 놓여 있다.
계획서에는 하나의 줄에 띄어쓰기를 기준으로 하여 L,R,U,D 중 하나의 문자가 반복적으로 적혀 있다.
각 문자는 왼쪽 오른쪽 위로 아래로 한칸씩 이동하라는 의미.
이때 여행가 A가 NxN 정사각형 공간을 벗어나는 움직임은 무시된다. 예시로 (1,1) 위치에서 L혹은 U를 만나면 그냥 무시하고 움직일 수 있는
문자가 오면 그때 움직인다.

입력조건
1. 공간의 크기를 나타내는 N 100이하
2. 여행가 A가 이동할 계획서 내용이 문자로 주어짐 100개이하

출력조건
최종 도착 좌표를 숫자로 표현
*/

/* 접근방법
 실제로 맵 안에 좌표로 있을 필요가 없는거 같다. 무슨 말이냐면 어차피 반환하는건 숫자 2개이고 그 숫자가 나오도록 조건을 
 동적으로 제어하면 될거 같다.
 N=5이면 1,1에서 5,5까지만 가능하다. L은 x-1 R은 x+1 U는 y-1 D는 y+1 하되 1~N까지 범위체크를 계속하며 초기화하고 넘어가는 방식
 입력 계획서가 100개의 문자로 이루어져있으므로 100번만 반복하면 될것 같다.
*/
//
//
#if 0
#include<iostream>
#include<vector>
#include<string>
using namespace std;

int rangeCheck(int n, int target) {
	if (target == 0) {
		return 1;
	}
	else if (target > n) {
		return n;
	}
	else {
		return target;
	}
}

vector<int> solution(int n, string str) {
	vector<int>answer = { 1,1 };

	for (auto n : str) {
		if (n == 'R') {
			answer[0]++;
			answer[0] = rangeCheck(n, answer[0]);
		}
		else if (n == 'L') {
			answer[0]--;
			answer[0] = rangeCheck(n, answer[0]);
		}		
		else if (n == 'U') {
			answer[1]--;
			answer[1] = rangeCheck(n, answer[1]);
		}		
		else if (n == 'D') {
			answer[1]++;
			answer[1] = rangeCheck(n, answer[1]);
		}
		else {
			continue;
		}
	}
	return answer;
}

int main() {
	int N = 5;
	string ss = "RRRUDD";
	auto res = solution(N, ss);
	cout << res[0] << endl;
	cout << res[1] << endl;
}

#endif

/* 4-2 시각
정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 
3이 하나라도 포함되는 모든 경우의 수를 구하는 프로그램을 작성하시오. 
예를 들어 1을 입력했을 때 다음은 3이 하나라도 포함되어 있으므로 세어야 하는 시각이다.

00시 00분 03초, 00시 13분 30초 등등

입력조건
정수 N이 입력됨 23이하

출력조건
3이 하나라도 포함되면 카운트하고 그 카운트한 횟수를 출력한다.
*/

/* 접근방법
1. 오케이 시간이 하나 증가할때마다 분이 반복되고 분이 하나 증가할때 마다 초가 반복된다.
2. 시간에 3이 포함되면 그 시간은 모두 3이 포함된다.

따라서 시간에 3이 들어있는지 먼저 바깥에서 체크하고 3이 들어있으면 3:00:00부터 3:59:59 까지 전부 체크
시간에 3이 들어있지 않으면?
분을 기준으로 3이 들어있는지 먼저 바깥에서 체크하고 3이 들어있으면 0:03:00부터 0:03:59 까지 전부 체크
분에도 3이 들어있지 않으면?
초를 기준으로 3이 들어있는거만 체크

그런데 이걸 조건만 체크해서 미리 계산되어있는 횟수를 더해야지 23:59:59초 까지 전부 하나씩 카운팅하면 시간 오버.
1. 초를 기준으로 3이 들어있는거 = 십의 자리수가 3인경우 10개 + (일의 자리가 3인경우 1개 * 십의자리가01245 5개) = 15개
2. 분을 기준으로 3이 들어있다면 = 60개
3. 시간을 기준으로 3이 들어있다면 = 60*60 = 3600개

N을 어떻게 돌면서 3을 체크할건가?
0부터 N까지 증가하면서 3을 체크하는 방법이 있을거 같고, 애초에 수학적으로 N이 주어지면 바로 계산되는 식도 있을 수 있을듯.
시간에 3이 포함된 경우는 3, 13, 23
N이 3이상 1번 N이 13이상 2번 N이 23이면 3번

시간을 기준으로 3이 들어있다면 3600개
시간을 기준으로 3이 안들어있다면 (01분~ 30분대 제외하고 59분까지의 초계산 (15+15+15+60+15+15+15+15+15+15)*5개 = 975개) 
+ (30분대의 초계산 600개) = 1575개
*/

//
//
#if 0
#include<iostream>
#include<vector>
using namespace std;

int solution(int n) {
	int h = 0;
	int m = 0;
	int answer = 0;
	while (h <= n) {
		if (h % 10 == 3){ //어차피 시간은 일의 자리수만 3이니까
			answer += 3600;
		}
		else {
			answer += 1575;
		}
		h++;
	}
	return answer;
}

int main() {
	int n = 5;
	cout << solution(n);

}
// 책내용 보충
// 하루 시간은 86000 밖에 안되기 때문에 시간초과는 발생할일이 없고 따라서 3중 포문으로 풀어도 괜찮다.
//

#endif

/* <2> <왕실의 나이트>
행복 왕국의 왕실 정원은 체스판과 같은 8x8 좌표 평면이다. 왕실 정원의 특정한 한 칸에 나이트가 서 있다. 나이트는 매우 충성스러운 신하로서 매일 무술을 연마한다.
나이트는 말을 타고 있기 때문에 이동을 할 때는 L자 형태로만 이동할 수 있으며 정원 밖으로는 나갈 수 없다. 
나이트는 특정한 위치에서 다음과 같은 2가지 경우로 이동할 수 있다.
1. 수평으로 두칸 이동한 뒤에 수직으로 한 칸 이동
2. 수직으로 두칸 이동한 뒤에 수평으로 한칸 이동
나이트가 어떤 특정한 위치에 있을때 이동할 수 있는 경우의 수를 출력하는 프로그램 짜기
행은 1~8로 열은 a~h로 표현한다.

입력조건
첫줄에 8x8평면에서 어느 위치에 나이트가 존재하는지를 알려주는 문자열이 입력됨

출력조건
첫째 줄에 나이트가 이동할 수 있는 경우의 수를 출력
*/

/* 접근방법
만약 아무 이상없다면 전방향 이동이 가능하다면 최대 경우의 수는 8가지이다. 위위오왼 2개 아아오왼 2개 왼왼위아 2개 오오위아 2개
그렇게 더해서 만들어진 좌표가 a보다 작거나 h보다 크거나 1보다 작거나 8보다 크거나 하면 그 좌표들은 카운팅을 무시한다.
*/
//
//
#if 0
#include<iostream>
#include<vector>
#include<string>
using namespace std;

int solution(string s) {
	int answer = 0;
	if (s[1] >= '3') { //위위 가능? 가능하면 오왼 체크
		if (s[0] >= 'b') { //왼 가능
			answer++;
		}
		if (s[0] <= 'g') {// 오 가능
			answer++;
		}
	}
	if (s[1] <= '6') {//아아 가능? 가능하면 오왼 체크
		if (s[0] >= 'b') { //왼 가능
			answer++;
		}
		if (s[0] <= 'g') {// 오 가능
			answer++;
		}
	}
	if (s[0] >= 'c') { //왼왼 가능? 가능하면 위아 체크
		if (s[1] >= '2') { //위 가능
			answer++;
		}
		if (s[1] <= '7') {//아 가능
			answer++;
		}
	}
	if (s[0] <= 'f') {//오오 가능? 가능하면 위아 체크
		if (s[1] >= '2') { //위 가능
			answer++;
		}
		if (s[1] <= '7') {//아 가능
			answer++;
		}
	}
	return answer;
}

//책 풀이를 보고 다시 짠 코드
int solution2(string s) {
	//위위오왼 2개 아아오왼 2개 왼왼위아 2개 오오위아 2개
	//입력은 열행
	int answer = 0;
	int row = s[0] - 'a' + 1;
	int col = s[1] - '0';
	vector<vector<int>> steps = { {1, 2}, {-1,2}, {1, -2},{-1,-2},{2,1},{2,-1},{-2,1},{-2,-1} };
	for (auto step : steps) {
		if ((col + step[0]) >= 1 and (col + step[0]) <= 8 and (row + step[1]) >= 1 and (row + step[1]) <= 8) {
			answer++;
		}
	}
	return answer;
}

int main() {
	string s = "";
	cin >> s;
	cout << endl;
	cout << solution(s) << endl;
	cout << solution2(s) << endl;
}

// 책풀이를 보고 든 생각 고찰
// 나의 풀이는 다중 이프문을 계속 겹쳐 있기 때문에 한번에 읽기에는 너무 길어져 불편했다. 
// 주석문을 결합하여 이해는 직관적이고 쉬울 수 있으나 조건들이 더 붙기 시작하면 더 복잡해질 구조일거 같다.
// 
// 책에서는 나이트가 이동할 수 있는 좌표증감읜 정수배열쌍 8가지를 저장하는 2차원 배열을 활용하였다.
// 나이트의 위치 입력을 행열을 구별하여 1~8 정수로 변환하는 계산이 추가로 들어갔다. 예를들어 a1이라면
// 열 = 'a'-'a' +1 ; 행 = '1' -'0';
// 나이트가 이동할 8가지 방향을 저장한 배열을 순회하며 각 행 열 에 알맞은 값을 더하고 조건식을 검사하여
// 1~8 안에 들어오는지 체크하여 카운팅한다.
//

#endif

/*<3> 게임 개발
현민이는 게임 캐릭터가 맵 안에서 움직이는 시스템을 개발 중이다. 캐릭터가 있는 장소는 1x1 크기의 정사각형으로
이뤄진 nxm 크기의 직사각형으로, 각각의 칸은 육지 또는 바다이다. 캐릭터는 동서남북 중 한 곳을 바라본다.
맵의 각 칸은 (A,B)로 나타낼 수 있고, A는 북쪽으로부터 떨어진 칸의 개수, B는 서쪽으로부터 떨어진 칸의 개수이다. 
캐릭터는 상하좌우로 움직일 수 있고, 바다로 되어 잇는 공간에는 갈 수 없다. 
캐릭터의 움직임을 설정하기 위해 정해 놓은 매뉴얼은 이러하다.

1. 현재 위치에서 현재 방향을 기준으로 왼쪽 방향(반시계 방향으로 90도 회전한 방향)부터 차례대로 갈 곳을 정한다.
2. 캐릭터의 바로 왼쪽 방향에 아직 가보지 않은 칸이 존재한다면, 왼쪽 방향으로 회전한 다음 왼쪽으로 한 칸을 전진한다.
왼쪽 방향에 가보지 않은 칸이 없다면, 왼쪽 방향으로 회전만 수행하고 1단계로 돌아간다.
3. 만약 네 방향 모두 이미 가본 칸이거나 바다로 되어 있는 칸인 경우에는, 바라보는 방향을 유지한채로 한 칸 뒤로가고 
1단계로 돌아간다. 단, 이때 뒤쪽 방향이 바다인 칸이라 뒤로 갈 수 없는 경우에는 움직임을 멈춘다.

입력조건
첫째 줄에 맵의 세로크기 N과 가로크기 M이 나온다. 각각 50이하
둘째 줄에 게임 캐릭터가 있는 칸의 좌표 (A,B)와 바라보는 방향 d가 각각 공백으로 구분하여 주어짐. d는 숫자로 구별됨
0: 북, 1: 동, 2: 남, 3:서
셋째 줄에 맵이 육지인지 바다인지에 대한 정보가 주어짐.0은 육지 1은 바다 맵의 외각은 항상 바다로 채워져 있음.
처음에 주어지는 캐릭터 위치는 무조건 육지이다.

출력조건
첫째 줄에 이동을 마친 후 캐릭터가 방문한 칸의 수를 출력한다.

입력 예시 
4 4
1 1 0
1111
1001
1101
1111
출력예시
3
입력 예시
6 6
1 1 0
111111
100001
110001
110011
111011
111111
출력 예시
7
*/
/* 접근방법
일단 매뉴얼대로 게임이 돌아가도록 로직을 구성해야 될것 같다. 추가적인 수학적 계산은 없어보인다. 일일히 현재 상태를 확인해야될것
입력값을 제대로 구조적으로 저장하고 접근하도록 한다.
입력조건에 따르면 50 x 50 맵이 만들어질거고 한번 탐색한 적이 있고 더이상 탐색할 수 없으면 종료되는 조건이므로 하나씩
탐색할 경우 2500번 반복을 하게 될것이다. 2500 안에 400번을 계산해도 무리 없으므로 하나씩 탐색은 시간오버 조건에 걸리지는 않을것

이 문제는 바다에는 갈 수 없고 한 번 밟은 구역은 다시는 밟지 않으므로 바다라고 생각해도 무리 없다. 라고 생각했지만 실상은 달랐다.
바로 3번의 뒤로가는 경우가 가능했고, 이때 뒤로 가는경우는 바다인지 육지인지를 구별한다는 점. 따라서 그냥 단순히 밟으면 
1로 바꿀려하면 안될것. 각 좌표마다 밟은적이 있는지 없는지 정보를 체크할 필요가 있을 것 같다. 그때 pair 자료형을 활용해봄.

왼쪽으로 돌아가는 방향은 -1 0일때만 3으로 됨.
*/

//
//
#if 0
#include<iostream>
#include<vector>
using namespace std;

int solution(int n, int m, vector<int>pos, int dir) {
	int answer = 1;//처음에 밟은 땅
	int temp = 0, rot = 0;
	vector<vector<pair<int, int>>> map;
	vector<pair<int, int>> rowmap;
	//맵 만들기
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			cin >> temp;
			rowmap.push_back(make_pair(temp, 0));
		}
		map.push_back(rowmap);
		rowmap.clear();
	}
	//2차원 배열의 행열은 앞쪽이 세로 y 행. 뒤쪽이 가로 x 열
	map[pos[0]][pos[1]].second = 1;
	//1번 왼쪽방향에 갈만한 곳이 있는지 체크하고 갈만한 곳이 있다면 회전후 직진
	//2번 왼쪽방향에 갈만한 곳이 없다면 회전만하고 다시 1번으로
	//3번 1번 2번 1번 2번 계속하다가 한바퀴를 돌았으면 방향은 유지한채 뒤로 1보 만약 뒤에가 바다라면 그때 끝
	//0: 북, 1: 동, 2: 남, 3:서
	//무조건 왼쪽으로 가는 조건이므로 0일땐 (0,-1) 3일땐 (1,0) 2일땐 (0,1) 1일땐 (-1,0)
	while (true) {
		if (dir == 0 and map[pos[0]][pos[1] - 1].first == 0 and map[pos[0]][pos[1] - 1].second == 0) { 
			//d==0 일때 왼쪽으로 갈수 있다면
			pos[1]--;	dir = 3;	answer++;	map[pos[0]][pos[1]].second = 1;	rot = 0;
		}
		else if (dir == 3 and map[pos[0]+1][pos[1]].first == 0 and map[pos[0] + 1][pos[1]].second == 0) {
			//d==3 일때 왼쪽으로 갈수 있다면
			pos[0]++;	dir--;	answer++;	 map[pos[0]][pos[1]].second = 1;	rot = 0;
		}
		else if (dir == 2 and map[pos[0]][pos[1] + 1].first == 0 and map[pos[0]][pos[1] + 1].second == 0) { 
			//d==2 일때 왼쪽으로 갈수 있다면
			pos[1]++;	dir--;	answer++;	map[pos[0]][pos[1]].second = 1;	rot = 0;
		}
		else if (dir == 1 and map[pos[0]-1][pos[1]].first == 0 and map[pos[0] - 1][pos[1]].second == 0) {
			//d==1 일때 왼쪽으로 갈수 있다면
			pos[0]--;	dir--;	answer++;	map[pos[0]][pos[1]].second = 1;	rot = 0;
		}
		else {
			if (dir == 0){		 //1회전 rot=4가 되면 3번을 수행할것
				dir = 3; rot++;
			}
			else {
				dir--;	rot++;
			}
		}
		if (rot == 4) {
			if (dir == 0 and map[pos[0]+1][pos[1]].first == 0) { //d==0 일때 아래가 육지라면
				pos[0]++;	rot = 0;
			}
			else if (dir == 3 and map[pos[0]][pos[1]+1].first == 0) { //d==3 일때 오른쪽이 육지라면
				pos[1]++;	rot = 0;
			}
			else if (dir == 2 and map[pos[0]-1][pos[1]].first == 0) { //d==2 일때 위쪽이 육지라면
				pos[0]--;	rot = 0;
			}
			else if (dir == 1 and map[pos[0]][pos[1]-1].first == 0) { //d==1 일때 왼쪽이 육지라면
				pos[1]--;	rot = 0;
			}
			else {// 어떤 방향이든 반대가 바다라면
				break;
			}
		}
	}

	return answer;
}

int main() {
	int N, M;
	cin >> N >> M;
	vector<int> position = { 0,0 };
	int dir = 0;
	cin >> position[0] >> position[1] >> dir;
	cout << solution(N, M, position, dir);
}
/*고찰
역시나 정답과는 멀어보이게 또 코드가 길어져 버렸다. 논리적으로는 문제도 없고 복잡하게 꼬여서 불필요한 횟수가 증가하거나 하는 문제는 없어보인다.
<책을 보고나서 정리>
1, 방향을 설정해서 이동하는 문제는 dx, dy라는 별도의 리스트를 만들어서 방향을 정하는 것이 효과적이다.

ex ) 북쪽을 바라보면 북쪽으로 이동하기 위해 x,y 좌표에 x += dx[0] , y += dy[0]을 수행하도록 한다. (-1,0)만큼 이동

2. 2차원 리스트를 선언할 때에는 컴프리헨션으로 리스트를 초기화하는 것이 효율적이다.

 ex) array = [[0] * m for _ in range(n)]

*/



#endif

//
//
#if 0
#include<iostream>
#include<vector>
using namespace std;

int main() {

}

#endif

//
//
#if 0
#include<iostream>
#include<vector>
using namespace std;

int main() {

}

#endif

//
//
#if 0
#include<iostream>
#include<vector>
using namespace std;

int main() {

}

#endif
