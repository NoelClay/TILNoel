/*2번
일렬로 나열된 n개의 집에 택배를 배달하려 한다. 배달할 물건은 모두 크기가 같은 재활용 택배 상자에
담아 배달한다. 배달을 다니면서 빈 재활용 택배 상자를 수거한다.
배달할 택배들은 모두 재활용 박스 안에 담겨서 물류창고에 보관되어 있고, i번째 집은 물류창고에서
거리 i만큼 떨어져있다. i번째 집은 j번째 집과 i-j만큼 떨어져 있다.
트럭에는 cap개 만큼 상자를 담을 수 있다. 트럭은 배달할 택배상자를 가들 실어 물류창고에서 출발하여 각
집에 배달하면서, 빈 상자들을 수거해 물류창고에 내린다.
각 집마다 배달할 재활용 택배 상자의 개수와 수거할 빈 상자들의 개수를 알고 있다면 트럭하나로 모든 배달과 수거를
마치고 물류창고까지 돌아올 때 총 이동거리가 최소가 되는 값을 구한다.

cap=4이고 5개의 집은 다음과 같을때
	집1	집2	집3	집4	집5
배달 1	0	3	1	2
수거 0	3	0	4	0

답은 16이다.
가는거리+오는거리는 항상 세트로 나오기에 나중에 곱2하면 될거 같다.

제한사항
1 <= cap <= 50		1 <= n <= 100000

<접근방법>
그리디 문제 같다.
무조건 가장 먼곳에 있는 녀석들을 다 해결봐야만 한다. 그리고 배달할 물건이 없더라도 수거할 물건이 있다면
반드시 가장 먼곳까지 찍고 돌아와야 한다. 배달도 0/수거도 0이 될때까지 반복조건을 돈다.

*/
#if 0
#include <string>
#include <vector>

using namespace std;

long long solution(int cap, int n, vector<int> deliveries, vector<int> pickups) {
    long long answer = -1;
    int delidx = n - 1, picidx = n - 1, temp=cap;
    while (delidx > 0 || picidx > 0) {
        while (temp!=0) {
            int temp = deliveries[delidx] - cap;
            //cap개 만큼 있으면 0이될것이고, cap보다 많이 있으면 남을 것이고, cap보다 적게 있으면 -가 될 것이다.
            //마이너스가 되었다면 그 이전것에도 영향을 준다는 것이고 그건 -개만큼 차감하면 된다.
            
        }
    }



    return answer;
}


#endif // 1
