// 1번
/* 괄호가 바르게 짝지어졌다는 것은 () 이런식으로 닫혀야 한다는 뜻
괄호로만 이루어진 문자열 s가 주어질때, 문자열 s가 올바르면 true 올바르지 않으면 false
<접근방법>
스택인가 큐인가 애매했는데 이건 스택이 맞는거 같다. 
괄호엔 규칙이 있다. 열릴땐 항상 ( 이거고 닫힐땐 항상 )로 닫혀야한다. 
열리지 않았으면 닫히면 안된다. 또 열리는 문의 개수와 닫히는 문의 개수는 같아야하며
짝지어져있어야 한다. 이것은 스택으로 풀수 있다.
<스택>
먼저 들어간 놈은 뒷전이고 맨 나중에 들어간 놈을 조회하고 없애는데 탁월하다. 이는
짝지어진 상태를 파악하기에 아주 좋다. '(' 열릴땐 스택에 넣고 ')' 닫힐땐 스택에서 뺀다.
뺄려고 했는데 없다? false
다 빼고났는데도 남아있다? false
괄호의 총 수는 같더라도 순서에 따라 true false를 만족하니 최적해
<시간초과>
s는 10만 이하의 자연수 이므로 s를 한번 선형탐색하는 거로 충분
*/
#if 0
#include<string>
#include <iostream>
#include<stack>

using namespace std;

string solution(string s)
{
    string answer = "true";
    stack<char> teststack;
    for (auto n : s) {
        if (n == '(') teststack.push(n);
        else if(n == ')') {
            if (teststack.empty()) {
                answer = "false";
                break;
            }
            else    teststack.pop();
        }
    }
    if (!teststack.empty()) answer = "false";
    cout << endl;
    return answer;
}

int main()
{
    cout << solution("()()"); // 정답 : true
    cout << solution("(())()"); // 정답 : true
    cout << solution(")()("); // 정답 : false
    cout << solution("(()("); // 정답 : false
}
#endif

// 2번 <미해결>
/*무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 한다. 구명보트는 작아서
한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있다.
예를 들어, 사람들의 몸무게가 70, 50, 80, 50 이고 구명보트의 무게 제한이 100이라면
2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번과 3번이 끼게 되면 100을 넘어가기에
같이 탈 수 없다. 최소한의 구명보트로 사람을 구출하려고함.

무인도에 갇힌 사람은 5만이하
몸무게는 40 ~ 240 까지 분포 소수점은 안따짐. 자연수
구명보트의 리미트는 40~ 240kg까지
구명 보트의 리미트는 항상 사람들의 몸무게중 최대값 보다는 크게.구출못하는 경우의 수는 없다.

<시간 제한>
사람은 5만명이다. 1만이 넘어간 순간 제곱은 안된다. nlogn 안에서 쇼부(정렬)
정렬후 선형탐색은 시간 널널

<접근방법>
그리디 알고리즘에 가까운듯. 가장 무거운 사람과 가장 가벼운 사람의 영향력이 지대하다기 보다는
결국 무게 총합을 리미트에 가깝게 하기 위한 조합을 항상 만들어낼 수 있다면 보트의 개수도
최소값이 될 것이다. 더한 나머지가 가장 작을 수록 이게 최소값이 되는거긴 한데 그게 최적해임을 
어떻게 증명하지?

1. 최소값들 먼저 다 더해보기 8
2. 최대값 하나 당 최소값 더해서 되는 경우 등록 -> 이쪽이 더 잘나오는거 2번째 예시로 확인
    2_1.얼만큼 탐색할 것인가? 일단 최소값을 더해볼때 초과한다? 그럼 탐색종료 그냥 자기자신만
    2_2.어떻게 탐색할 것인가?
다시 취소 세번째 예시에서 최대값과 최소값 조합이 무조건 최적해가 아니라는것을 확인

3. 혹시 이런건? 보트에 많이 태울수록 유리
2로 나눈 몫보다 작은 애들은 2명씩 타고 3으로 나눈 몫보다 작은 애들은 3명씩 타고...
그런데 그렇다고해서 2로 나눈 몫보다 큰 애들은 반드시 2명을 못태운다? 아니지.
2로나눈 몫보다 작은 애들이랑 짝짝꿍 잘 맞으면 오히려 더 최적조합이 된다. 
약수의 조합이 베스트 조합이긴하다. 약수를 구하는게 일단 키포인트이지 않을까?

약수를 구하면 같은 원소끼리는 일단 다 묶고 그 약수보다 작은 애들그룹 큰 애들 그룹으로 나눈다. 
40kg 이상이므로 리미트의 약수중에 40kg 이상인 약수만 비교군이 될 것이다. 가장 작은 약수가 가장 많이
받을 수 있는 그룹일 테니까 가장 작은 약수부터 찾아본다.

<약수 찾기>
어떤 수의 루트를 씌운 값보다 작거나 같은 수까지만 약수를 구해서 찾아보면된다. 240이니까 15까지만
구해보면 된다. 반복 횟수 15 하나씩 줄여가면서 나누어 떨어지는 수를 찾아 약수집합에 넣고 
그 수가 40 미만이 되면 종료한다.

<약수를 찾았다면 음...>
약수로 이루어진 조합은 최강이라 그녀석들은 조합하면 바로 빼버린다.

근데 그런애들이 없다면 음.. 약수보다 작은애들 그리고 그보다 큰애들이라면 
무조건 최대로 들어갈수 있는 조합을 구성하기엔 글러먹었다는 소리이다.

이런 방법으로 푸는게 답이 맞나? 예를들어 1 2 3 4 6 12 가 있을때 
2 3 4 5 5 5 6 7 7 7 8 8 8 9 9 9 10 10 10 11 11 11 12 이렇게 있다면
2가 하나니까 총 6개가 들어가는 최대 조합은 불가능하다. 나머지들도 마찬가지.
10과 2를 더하는게 베스트인데. 이걸 어떻게 일반화 하지? 또 자료 하나하나 데이터 하나하나마다
전체를 탐색하며 찾는것은 시간 초과가 백프로 뜬다.
그럼 그룹화를 하는게 맞나? 2이상 3이하 3이상 4이하 이렇게? 
그리고 최소값이랑 더해도 도저히 안되는 구제불능 따로 빼고? 이렇게?

그룹화를 했다면 찾을땐 리미트에서 현재 수를 빼고나서 남은 수가 속한 그룹을 찾아 이동?
그렇다면 최대값부터 어떻게 정리하는 방식을 고수하기 전에 약수를 먼저 싹 빼고나서 최대값부터?

위 방법이 아닌거 같다. 아무래도 이건 아니다.


*/
#if 0
#include <string>
#include <vector>
#include <iostream>
#include <cmath>
#include <algorithm>

using namespace std;

vector<int> divisor(int limit) {
    int a = sqrt(limit);
    vector<int> div;
    for (int i = a; i > 0; i--) {
        if (limit % i == 0 && limit/i>=40)  div.push_back(limit / i);
        //그러니까 리미트 자체도 들어가기에 소수도 만족한다.
        //40이상인 최소값 부터 들어가기에 정렬도 되어있다.
    }
    return div;
}
bool cmp(int a, int b) {
    return a > b;
}
int solution(vector<int> people, int limit) {
    int answer = 0;
    auto div = divisor(limit);
    int tempidx = div.size();//약수중 가장 큰 녀석부터 조회
    sort(people.begin(), people.end(), cmp);
    vector<vector<int>> peoplesector(div.size()+1);

    //약수집합으로 사람들을 구별한다. 구간별로 나눔
    for (int i = 0; i < people.size();i++) {
        if (tempidx==0) {//마지막 비교군 최소 약수보다 작은 수들 밖에 안남은 상황
            peoplesector[tempidx].push_back(people[i]);
        }
        else if(people[i]<=div[tempidx]){
            //아직 tempidx 진행도가 1이상일때, 약수와 약수사이에 구간에 집어넣는다.
            //초기 약수는 자기자신도 들어가도록 설정해놨기에 가장 큰 값으로 초기 약수보다
            //큰 무게는 존재하지 않는다.
            if (people[i] <= div[tempidx-1]) {
                //가장 큰 약수보다 더 작은 값이 people 그룹의 최대값이라면
                //그룹을 한 단계 낮출 필요가 있다. 잠시만.. 몇단계를 낮춰야될 경우의 수도 있다..

            }
            peoplesector[tempidx].push_back(people[i]);
        }
    }
    //약수집합 찾아 제거하기 div는 최대길이 는 240일때 7 따라서 선탐해도 35만 꽤나 많네
    for (int i = 0; i < div.size(); i++) {
        int temp = div[i];
        int cnt = limit / temp; //총 몇개 있어야 하는지.

    }

    return answer;
}

int main()
{
    cout << solution({ 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140 }, 150);//8
    cout << solution({ 40,41,42,43,44,45, 46, 47, 48, 49, 50, 51 }, 100);//6
    cout << solution({ 40,40,40,40,40,40,41,42,43,44,45, 46, 47, 48, 49, 50, 60, 60 }, 120);//8
    cout << solution({ 70, 50, 80, 50 }, 100); // 정답 : 3
    cout << solution({ 70, 80, 50 }, 100); // 정답 : 3
}
#endif